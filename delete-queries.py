#!/usr/bin/env python3

import argparse
import collections
import datetime
import json
import operator
import subprocess


# Contract represents a contract in ua-contracts.
Contract = collections.namedtuple("Contract", "id encoded_id effective_to products account_id account_name")

# Define contract related tables.
CONTRACT_RELATED_TABLES = (
    "contract_tokens",
    "contract_products",
    "contract_affordances",
    "contract_allowances",
    "contract_directives",
    "contract_obligations",
    "contract_external_asset_ids",
    "contract_machines",
    "resource_access",
)

now = datetime.datetime.now()


def run_contract(cmd, *args):
    """Run the contract CLI with the given subcommnd and args."""
    command = ("contract", cmd) + tuple(args)
    return subprocess.check_output(command).decode("utf-8")


def get_account_contracts(ids):
    """Return a dictionary mapping account ids to contracts with the given ids."""
    account_contracts = {}
    for id in ids:
        encoded_id = run_contract("encode-id", "c", id).strip()
        out = run_contract("show-contract", encoded_id, "--format", "json")
        info = json.loads(out)
        contract_info, account_info = info["contractInfo"], info["accountInfo"]
        effective_to = contract_info.get("effectiveTo")
        if effective_to is not None:
            try:
                effective_to = datetime.datetime.strptime(effective_to, "%Y-%m-%dT%H:%M:%S.%f%z")
            except ValueError:
                effective_to = datetime.datetime.strptime(effective_to, "%Y-%m-%dT%H:%M:%S%z")
            effective_to = effective_to.replace(tzinfo=None)
        contract = Contract(
            id=id,
            encoded_id=contract_info["id"],
            effective_to=effective_to,
            products=", ".join(contract_info['products']),
            account_id=account_info["id"],
            account_name=account_info["name"],
        )
        account_contracts.setdefault(contract.account_id, []).append(contract)
    return account_contracts


def get_contracts_to_delete(account_contracts):
    """Return a list of contracts to be deleted and a problematic contracts from the given account_contracts map."""
    contracts_to_delete, contracts_not_expiring = [], []
    for account_id, contracts in account_contracts.items():
        contracts_not_expiring.extend(c for c in contracts if c.effective_to is None)
        contracts = sorted(
            [c for c in contracts if c.effective_to is not None],
            key=operator.attrgetter("effective_to"))
        while len(contracts) > 1:
            if contracts[0].effective_to >= now:
                raise ValueError(f"multiple contracts effective at the same time: {contracts}")
            contracts_to_delete.append(contracts.pop(0))
    return contracts_to_delete, contracts_not_expiring


def get_delete_queries(id):
    """Return a list of queries to be run to delete a contract with the given id."""
    queries = [f"DELETE FROM {table} WHERE contract_id = '{id}';" for table in CONTRACT_RELATED_TABLES]
    queries.append(f"DELETE FROM contracts WHERE id = '{id}';")
    return queries


def setup():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "file", type=argparse.FileType("r"),
        help="name of a file containing a list of contract ids separated by newlines")
    return parser.parse_args()


def main(file):
    ids = [line.strip() for line in file]
    account_contracts = get_account_contracts(ids)
    contracts_to_delete, contracts_not_expiring = get_contracts_to_delete(account_contracts)

    if contracts_not_expiring:
        print("\n* problematic contracts (not expiring):\n")
        for contract in contracts_not_expiring:
            print(f"- {contract.products} {contract.encoded_id}")
            print(f"  {contract.id}")
            print(f"  owned by {contract.account_name} ({contract.account_id})")

    if not contracts_to_delete:
        print("no contracts to delete")
        return

    print("\n* contracts to delete:\n")
    for contract in contracts_to_delete:
        print(contract.encoded_id)

    print("\n* queries:\n")
    print("-- Queries are generated by running the script at")
    print("-- https://github.com/frankban/yellow-tools/blob/master/delete-queries.py")
    for contract in contracts_to_delete:
        print(f"\n-- Delete {contract.products} contract {contract.encoded_id}")
        print(f"-- owned by {contract.account_id} effective to {contract.effective_to}")
        queries = get_delete_queries(contract.id)
        print("\n".join(queries))


if __name__ == "__main__":
    args = setup()
    main(args.file)
